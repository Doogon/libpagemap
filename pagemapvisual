#!/usr/bin/python

# pagemapvisual - tool for graphical representation of pagemap interface
# Copyright (C) 2010 Red Hat, Inc. All rights reserved.
#
#     This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Petr Holasek , pholasek@redhat.com

import pygtk
pygtk.require('2.0')
import gtk
import os
import sys
import array
import time
from ctypes import *

class KPAGEMAP_T(Structure):
    pass

class PROC_MAPPING(Structure):
    pass

class PAGEMAP_LIST(Structure):
    pass

class PAGEMAP_T(Structure):
    _fields_ = [("pid", c_int),
        ("mappings", POINTER(PROC_MAPPING)),
        ("cmdline", c_char * 128),
        ("uss", c_ulong),
        ("pss", c_ulong),
        ("swap", c_ulong),
        ("res", c_ulong),
        ("shr", c_ulong),
        ("n_drt", c_ulong),
        ("n_uptd", c_ulong),
        ("n_wback", c_ulong),
        ("n_err", c_ulong),
        ("n_lck", c_ulong),
        ("n_slab", c_ulong),
        ("n_buddy", c_ulong),
        ("n_cmpndh", c_ulong),
        ("n_cmpndt", c_ulong),
        ("n_ksm", c_ulong),
        ("n_hwpois", c_ulong),
        ("n_huge", c_ulong),
        ("n_npage", c_ulong),
        ("n_mmap", c_ulong),
        ("n_anon", c_ulong),
        ("n_swpche", c_ulong),
        ("n_swpbck", c_ulong),
        ("n_onlru", c_ulong),
        ("n_actlru", c_ulong),
        ("n_unevctb", c_ulong),
        ("n_referenced", c_ulong),
        ("n_2recycle", c_ulong)
    ]

class PAGEMAP_TBL(Structure):
    _fields_ = [("start", POINTER(PAGEMAP_LIST)),
        ("curr", POINTER(PAGEMAP_LIST)),
        ("size", c_ulong),
        ("flags", c_int),
        ("kpagemap", POINTER(KPAGEMAP_T))
    ]

class PagemapData:
    '''
    Class which encapsulate libpagemap operations
    '''
    def __init__(self):
        libpagemap = cdll.LoadLibrary("libpagemap.so")
        self.init_pgmap_table = libpagemap.init_pgmap_table
        self.init_pgmap_table.restype = POINTER(PAGEMAP_TBL)
        self.open_pgmap_table = libpagemap.open_pgmap_table
        self.open_pgmap_table.restype = POINTER(PAGEMAP_TBL)
        self.reset_table_pos = libpagemap.reset_table_pos
        self.iterate_over_all = libpagemap.iterate_over_all
        self.iterate_over_all.restype = POINTER(PAGEMAP_T) 
        self.get_ram_size = libpagemap.get_ram_size
        self.get_ram_size.restype = c_ulonglong
        self.get_kpgcnt = libpagemap.get_kpgcnt
        self.get_kpgcnt.restype = c_ulonglong
        self.get_kpgflg = libpagemap.get_kpgflg
        self.get_kpgflg.restype = c_ulonglong

        self.table = pointer(PAGEMAP_TBL())
        self.pagecount = 0

    def refresh_procs(self):
        self.table = self.init_pgmap_table(self.table)

    def refresh_pagecount(self):
        self.pagecount = self.get_ram_size(self.table)

    def get_pagecount(self):
        self.refresh_pagecount()
        return self.pagecount

    def get_count(self,page):
        return self.get_kpgcnt(self.table, page)

    def get_flags(self,page):
        return self.get_kpgflg(self.table, page)

    def refresh_data(self):
        #self.open_pgmap_table(self.table) 
        pass

    def clean_data(self):
        pass #close 

class Painter:
    '''
    Class which invoke gtk paintings of pgmap_data class to Window
    '''

    def __init__(self):
        self.pagemap = PagemapData()
        time.sleep(3)
        self.pagemap.refresh_procs()
        self.pgcnt = self.pagemap.get_pagecount()
        self.scr_w = 1024
        self.scr_h = self.pgcnt/self.scr_w
        self.canvas = MemoryCanvas(self.scr_w,self.scr_h)
        self.pixbuff = array.array('B', '\0'*(3*self.scr_w*self.scr_h+1024))

    def test(self):
        self.pagemap.refresh_procs()
        self.pagemap.refresh_pagecount()
        ## prints sharing of all pages in system

    def __page2pixel(self,page):
        '''
        For drawing
        '''
        pass

    def __pixel2page(self,x,y):
        '''
        For taking of page address from mouse pointer mem-picture
        '''
        pass

    def draw_it(self):
        self.canvas.draw_pixbuff(self.pixbuff.tostring())

    def kpgcnt_pixbuff(self):
        for i in range(self.pgcnt):
            cnt = self.pagemap.get_count(i)
            if cnt > 0:
                self.pixbuff[3 * i] = 255
            else:
                self.pixbuff[3 * i] = 100

    def kpgflg_pixbuff(self):
        pass


    def main(self):
        gtk.main()
        return 0

class MemoryCanvas: 
    '''
    Graphical part of application
    '''
    def __init__(self, width, height):
        self.width = width
        self.height = height
        window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        window.set_title("picture of memory")
        window.connect("destroy", lambda w: gtk.main_quit())
        self.area = gtk.DrawingArea()
        self.area.set_size_request(width, height) 
        self.sw = gtk.ScrolledWindow()
        self.sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        window.add(self.sw)
        self.sw.add_with_viewport(self.area)

        self.sw.show()
        self.area.show()
        window.show()
        self.style = self.area.get_style()
        self.gc = self.style.fg_gc[gtk.STATE_NORMAL]

    def draw_pixbuff(self, buff):
        '''
        Buffer is passed as string
        '''
        self.area.window.draw_rgb_image(self.gc, 0, 0, self.width, self.height,
                gtk.gdk.RGB_DITHER_NONE, buff, self.width*3)


if __name__ == "__main__":
    p = Painter()
    p.kpgcnt_pixbuff()
    p.draw_it()
    p.main()

    
    

