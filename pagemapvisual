#!/usr/bin/python

# pagemapvisual - tool for graphical representation of pagemap interface
# Copyright (C) 2010 Red Hat, Inc. All rights reserved.
#
#     This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Petr Holasek , pholasek@redhat.com

import pygtk
pygtk.require('2.0')
import gtk
import os
import sys
import array
import time
import threading
import gobject
import argparse
import pagemapdata

#TODO: parametr for distinguish what to count
class CountThread(threading.Thread):
    def __init__(self, painter):
        self.painter = painter
        threading.Thread.__init__(self)
    def run (self):
        while True:
            p.refresh_kcount()
            p.kpgcnt_pixbuff()

parser = argparse.ArgumentParser()
parser.add_argument('--count', action='store_true')
parser.add_argument('--flags', action='store_true')


class Painter:
    '''
    Class which invoke gtk paintings of pgmap_data class to Window
    '''

    def __init__(self,args):
        self.args = args
        self.pagemap = pagemapdata.PagemapData()
        self.pgcnt = self.pagemap.get_pagecount()
        self.scr_w = 1024
        self.scr_h = (self.pgcnt+1023)/self.scr_w
        print "count: ",self.pgcnt, self.scr_w, "x3x" ,self.scr_h," = ", 3*self.scr_w*self.scr_h
        self.canvas = MemoryCanvas(self.scr_w,self.scr_h)
        #self.refresh_timer()
        if self.args.count:
            self.refresh_kcount()
            self.kpgcnt_pixbuff()
        elif self.args.flags:
            self.refresh_kflags()
            self.kpgflg_pixbuff()

    def test(self):
        pass
        ## prints sharing of all pages in system


    def pixel2page(self,x,y):
        '''
        For taking of page address from mouse pointer mem-picture
        '''
        pass

    def draw_it(self):
        self.canvas.draw_pixbuff()

    def refresh_kcount(self):
        self.pagemap.fill_count()

    def refresh_kflags(self):
        self.pagemap.fill_flags()

    def kpgcnt_pixbuff(self):
        for i in range(self.pgcnt):
            cnt = self.pagemap.get_count(i)
            if cnt > 0:
                self.canvas.set_RGB4page(i,min(255, cnt * 30 + 100))
            else:
                self.canvas.set_RGB4page(i,0)

        self.draw_it()

    def kpgflg_pixbuff(self):
        for i in range(self.pgcnt):
            flags = self.pagemap.get_flags(i)
            if flags & (1L << 20): # NOPAGE
                self.canvas.set_RGB4page(i,0)
            elif flags & (1L << 4): # DIRTY
                self.canvas.set_RGB4page(i,255)
            elif flags & (1L << 13): #SWAPCACHE
                self.canvas.set_RGB4page(i,0,255)
            elif flags & (1L << 12): #ANON
                self.canvas.set_RGB4page(i,0,0,255)

        self.draw_it()

    def refresh_timer(self):
        self.refresh_kcount()
        self.kpgcnt_pixbuff()
        gobject.timeout_add(300, self.refresh_timer)

    def main(self):
        gtk.main()
        return 0

class MemoryCanvas: 
    '''
    Graphical part of application
    '''
    def __init__(self, width, height):
        self.width = width
        self.height = height
        # WHY ?
        self.pixbuff = array.array('B', '\0'*(3*self.width*(self.height+32)))
        window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        window.set_title("picture of memory")
        window.connect("destroy", lambda w: gtk.main_quit())
        self.area = gtk.DrawingArea()
        self.area.set_size_request(self.width, self.height) 
        self.area.connect("expose-event", self.area_redraw)
        self.sw = gtk.ScrolledWindow()
        self.sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        window.add(self.sw)
        self.sw.add_with_viewport(self.area)

        self.sw.show()
        self.area.show()
        window.show()
        self.style = self.area.get_style()
        self.gc = self.style.fg_gc[gtk.STATE_NORMAL]

    def page2pixel(self,page):
        '''
        Place page into block of 1024 pages (usually 4MB)
        '''
        block_seq = int(page) / 1024
        x = block_seq % 32 * 32 + (page % 1024) % 32
        y = block_seq / 32 * 32 + (page % 1024) / 32
        return x, y

    def pixel2page(self, x, y):
        '''
        Computes pixels of page on pixel
        '''
        #Stolen code O_o
        #block = ((y >> 5) << 5) + (x >> 5)
        #return (block << 10) + ((y & 31) << 5) + (x & 31)

    def set_RGB4page(self, page, red, green=0, blue=0):
        x, y = self.page2pixel(page)
        pos = y * 1024 + x

        try:
            self.pixbuff[pos*3] = red
            self.pixbuff[pos*3 + 1] = green
            self.pixbuff[pos*3 + 2] = blue
        except:
            print "ERR:",pos*3

    def draw_pixbuff(self):
        '''
        Buffer is passed as string
        '''
        self.area.window.draw_rgb_image(self.gc, 0, 0, self.width, self.height,
                gtk.gdk.RGB_DITHER_NONE, self.pixbuff.tostring(), self.width*3)

    def area_redraw(self, area, event):
        '''
        expose-event handler
        '''
        self.draw_pixbuff()
        return True


if __name__ == "__main__":
    args = parser.parse_args()
    p = Painter(args)
    gtk.main()
    

    
    

