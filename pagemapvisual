#!/usr/bin/env python

# pagemapvisual - tool for graphical representation of pagemap interface
# Copyright (C) 2010 Red Hat, Inc. All rights reserved.
#
#     This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Petr Holasek , pholasek@redhat.com

import pygtk
pygtk.require('2.0')
import gtk
import os
import sys
import array
import time
import threading
import gobject
import argparse
import pagemapdata
import matplotlib
from pylab import *
import numpy.numarray as na

#TODO: 
#      Speed-up pagemapdata.py module and do some refresh stuff
#            Threads on backgroud? 
#      Patch kernel => slab distortion
#      /proc/[pid]/pagemap stuff
# Type of graphs:
#   count * pie chart - percentage of shared pages (0-6%,1-80%..)
#         * bar chart - percentage of shared pages (0-6%,1-80%..)
#   flags * bar chart - percentage of used flags (buddy-6%,slab-80%..) NOT IMPLEMENT
#   pagemap * pie chart(s) - percentage by processes by every statistics (USS,PSS,SWAP,SHARE,RES)



COUNT = 1
FLAGS = 2
PGMAP = 3

BAR   = 4
PIE   = 5

PID   = 6
NAME  = 7

USS   = 8
PSS   = 9
SWAP  = 10
RES   = 11
SHR   = 12

parser = argparse.ArgumentParser()
parser.add_argument('source', choices=['pagecount','pageflags','pagemap'],help='source of data')
parser.add_argument('type', choices=['bar','pie'], help='type of chart')
parser.add_argument('--stat', nargs='?', const='uss', default='uss', help='type of statistics to plot STAT=[uss|pss|shr|swap|res] uss is default')
parser.add_argument('--label', nargs='?', const='name', default='name', help='type of label on pagemap statistics LABEL=[name|pid]')
parser.add_argument('--filtery', nargs='?', const='', default='', help='filter used for y-axis values FILTERY=[[from]:[to]]')
parser.add_argument('--logy', action='store_true', help='enable log scale on y-axis')


class RuntimeError(Exception):
    '''
    Base error class
    '''
    pass


class Painter:
    '''
    Class which invoke gtk paintings of pgmap_data class to Window
    '''

    def __init__(self,args):
        self.args = args
        try:
            self.pagemap = pagemapdata.PagemapData()
        except pagemapdata.NoPagemapError:
            sys.exit("No access to pagemap interface.Exit.")
        if args.source == 'pagecount':
            self.s_src = COUNT
            self.texttitle = 'Number of page shares'
        elif args.source == 'pageflags':
            self.s_src = FLAGS
            self.texttitle = 'Page flags'
        elif args.source == 'pagemap':
            self.s_src = PGMAP
        else:
            self.s_type = -1 # should never happen

        if args.logy == True:
            self.logar = True
        else:
            self.logar = False

        if args.type == 'bar':
            self.s_type = BAR
        elif args.type == 'pie':
            self.s_type = PIE
        else:
            self.s_type = -1 # should never happen

        if args.label == 'name':
            self.l_type = NAME
        elif args.label == 'pid':
            self.l_type = PID
        else:
            self.s_type = NAME # should never happen

        if self.s_src == PGMAP:
            if args.stat == 'uss':
                self.p_type = USS
                self.texttitle = 'USS of system processes'
            elif args.stat == 'pss':
                self.p_type = PSS
                self.texttitle = 'PSS of system processes'
            elif args.stat == 'shr':
                self.p_type = SHR
                self.texttitle = 'SHR of system processes'
            elif args.stat == 'swap':
                self.p_type = SWAP
                self.texttitle = 'SWAP of system processes'
            elif args.stat == 'res':
                self.p_type = RES
                self.texttitle = 'RES of system processes'
            else:
                self.p_type = USS # should never happen
                self.texttitle = 'USS of system processes'

            self.texttitle = ''.join([self.texttitle,' in kB'])

        self.source_switch = {
                               COUNT : self.prepare_count,
                               FLAGS : self.prepare_flags,
                               PGMAP : self.prepare_pagemap
                             }
        self.type_switch = {
                             BAR : self.draw_bar,
                             PIE : self.draw_pie
                           }

        self.p_data = {}

    def prepare_count(self):
        '''
        Make dictionary from kpgacount values
        '''
        self.p_data = {}
        pgcount = p.pagemap.get_pagecount()
        p.pagemap.fill_count()
        for i in range(pgcount):
            c = p.pagemap.get_count(i)
            if c < 100:
                if not c in self.p_data:
                    self.p_data[c] = 1
                else:
                    self.p_data[c] += 1


    def prepare_flags(self):
        self.p_data = {}

    def prepare_pagemap(self):
        self.p_data = {}
        p.pagemap.refresh_pids()
        p.pagemap.refresh_pgmap()
        # fill self.p_data due requested value
        for k, v in p.pagemap.kpagemap.items():
            if self.l_type == NAME:
                label_key = v[5]
            elif self.l_type == PID:
                label_key = k

            #uss
            if self.p_type == USS:
                self.p_data[label_key] = v[0]
            elif self.p_type == PSS:
                self.p_data[label_key] = v[1]
            elif self.p_type == SHR:
                self.p_data[label_key] = v[2]
            elif self.p_type == RES:
                self.p_data[label_key] = v[3]
            elif self.p_type == SWAP:
                self.p_data[label_key] = v[4]

         
    def draw_bar(self):
        '''
        Plots bar graph
        '''
        width = 0.2
        #figure(1, figsize=(6,6))
        #ax = axes([0.1, 0.1, 0.8, 0.8])
        xlocations = na.array(range(len(self.p_data.keys())))
        xlocations_t = na.array(range(1,len(self.p_data.keys())+1))

        bar(xlocations, self.p_data.values(), log=self.logar)
        title(self.texttitle, bbox={'facecolor':'0.8', 'pad':5})
        if self.s_src == PGMAP:
            xticks(xlocations_t, self.p_data.keys(),rotation='vertical') # for big charts
        else:
            xticks(xlocations, self.p_data.keys()) # for big charts
        show()
 
    def draw_pie(self):
        '''
        Plots pie graph
        '''
        figure(1, figsize=(6,6))
        ax = axes([0.1, 0.1, 0.8, 0.8])
        chart = pie(self.p_data.values(),labels=self.p_data.keys(), shadow=False)

        title(self.texttitle, bbox={'facecolor':'0.8', 'pad':5})

        show()

    def filter_parse(self, filter_str):
        '''
        Method parses given filter values
        '''
        if filter_str != '':
            values = filter_str.split(':')
        else:
            values = ''
            minim, maxim =  None, None
        if len(values) != 2:
            minim, maxim =  None, None
        else:
            if values[0] == '':
                minim = None
            else:
                try:
                    minim = int(values[0])
                except:
                    minim = None
            if values[1] == '':
                maxim = None
            else:
                try:
                    maxim = int(values[1])
                except:
                    maxim = None
        if minim and maxim and minim > maxim:
            return None, None
        return minim, maxim

    def filter_values(self):
        '''
        Method filters values to plot in order of given filter values
        '''
        minim_y, maxim_y = self.filter_parse(self.args.filtery)
        for k in self.p_data.keys():
            if minim_y:
                if self.p_data[k] < minim_y:
                    del self.p_data[k]
                    continue
            if maxim_y:
                if self.p_data[k] > maxim_y:
                    del self.p_data[k]
        

    def run_plot(self):
        '''
        Core method which starts data prepare and plot
        '''
        print 'Preparing data . . .'
        self.source_switch.get(self.s_src, 1)()
        self.filter_values()
        print 'Ploting data . . .'
        self.type_switch.get(self.s_type, 1)()


if __name__ == "__main__":
    args = parser.parse_args()
    p = Painter(args)
    p.run_plot()



    

    
    

