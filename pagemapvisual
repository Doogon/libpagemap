#!/usr/bin/env python

# pagemapvisual - tool for graphical representation of pagemap interface
# Copyright (C) 2010 Red Hat, Inc. All rights reserved.
#
#     This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Author: Petr Holasek , pholasek@redhat.com

import pygtk
pygtk.require('2.0')
import gtk
import os
import sys
import array
import time
import threading
import gobject
import argparse
import pagemapdata

#TODO: Threads? :D
#      Draw legend
#      Patch kernel => slab distortion
#      /proc/[pid]/pagemap stuff
#      Legend and canvas alongside
#      Zoom :D

class CountThread(threading.Thread):
    def __init__(self, painter):
        self.painter = painter
        threading.Thread.__init__(self)
    def run (self):
        while True:
            p.refresh_kcount()
            p.kpgcnt_pixbuff()

parser = argparse.ArgumentParser()
parser.add_argument('--count', action='store_true')
parser.add_argument('--flags', action='store_true')


class Painter:
    '''
    Class which invoke gtk paintings of pgmap_data class to Window
    '''

    def __init__(self,args):
        self.args = args
        self.pagemap = pagemapdata.PagemapData()
        self.pgcnt = self.pagemap.get_pagecount()
        self.scr_w = 1024
        self.scr_h = (self.pgcnt+1023)/self.scr_w
        self.count_int = 30;
        self.count_base = 100;
        print "count: ",self.pgcnt, self.scr_w, "x3x" ,self.scr_h," = ", 3*self.scr_w*self.scr_h
        #self.refresh_timer()

    def paint(self):
        if True:
            if self.args.count:
                self.refresh_kcount()
                self.kpgcnt_pixbuff()
            elif self.args.flags:
                self.refresh_kflags()
                self.kpgflg_pixbuff()

    def draw_it(self):
        canvas.draw_pixbuff()

    def refresh_kcount(self):
        self.pagemap.fill_count()

    def refresh_kflags(self):
        self.pagemap.fill_flags()

    def kpgcnt_pixbuff(self):
        for i in range(self.pgcnt):
            cnt = self.pagemap.get_count(i)
            if cnt > 0:
                canvas.set_RGB4page(i,min(255, cnt * self.count_int + self.count_base))
            else:
                canvas.set_RGB4page(i,0)

        self.draw_it()

    def kpgflg_pixbuff(self):
        for i in range(self.pgcnt):
            flags = self.pagemap.get_flags(i)
            if flags & (1L << 20): # NOPAGE
                canvas.set_RGB4page(i,0)
            elif flags & (1L << 4): # DIRTY
                canvas.set_RGB4page(i,255)
            elif flags & (1L << 13): #SWAPCACHE
                canvas.set_RGB4page(i,0,255)
            elif flags & (1L << 12): #ANON
                canvas.set_RGB4page(i,0,0,255)

        self.draw_it()

    def refresh_timer(self):
        self.refresh_kcount()
        self.kpgcnt_pixbuff()
        gobject.timeout_add(300, self.refresh_timer)

    def main(self):
        gtk.main()
        return 0

class Legend:
    '''
    Window with briefing of colours of pagemap visualization
    '''
    def __init__(self, width, height, type):
        self.width = width
        self.height = height
        self.type = type
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.set_default_size(self.width, self.height)
        self.window.set_title('Legend')
        self.window.connect('destroy', lambda w: gtk.main_quit)
        self.window.set_border_width(5)

        main_box = gtk.VBox(False, 1)
        self.window.add(main_box)

        self.frame_page = gtk.Frame('Address of current page')
        self.label_page = gtk.Label('0xdeadbeef')
        self.frame_page.add(self.label_page)
        main_box.pack_start(self.frame_page,False,False,0)
        if self.type.count:
            self.frame_data = gtk.Frame('Current page count')
        elif self.type.flags:
            self.frame_data = gtk.Frame('Current page flags')
        else:
            self.frame_data = gtk.Frame('Wrong args')
        self.label_data = gtk.Label('0xdeadbeef')
        self.frame_data.add(self.label_data)
        main_box.pack_start(self.frame_data,False,False,0)
        self.area = gtk.DrawingArea()
        main_box.pack_start(self.area,False,False,0)

        self.window.show_all()

        self.gc = self.area.style.fg_gc[gtk.STATE_NORMAL]

    def draw_info(self):
        if self.type.count:
            self.g_legend = self.g_count()
        elif self.type.flags:
            self.g_legend = self.g_flags()
        else:
            self.g_legend = None

    def set_data(self, page):
        self.label_page.set_text("0x%016x" % (page*4096))
        if self.type.count:
            self.label_data.set_text("%d" % p.pagemap.get_count(page))
        elif self.type.flags:
            self.label_data.set_text(bin(p.pagemap.get_flags(page)))

    def g_count(self):
        base = p.count_base
        interval = p.count_int
        self.area.draw_rectangle(self.gc, TRUE, 0,0,100,100)

    def g_flags(self):
        pass

class MemoryCanvas: 
    '''
    Graphical part of application
    '''
    def __init__(self, width, height):
        self.width = width
        self.height = height
        # WHY ?
        self.pixbuff = array.array('B', '\0'*(3*self.width*(self.height+32)))
        window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        window.set_title("Pagemapvisual")
        window.connect("destroy", lambda w: gtk.main_quit())
        window.set_default_size(self.width, self.height)
        self.area = gtk.DrawingArea()
        self.area.set_size_request(self.width, self.height) 
        self.area.set_events(gtk.gdk.POINTER_MOTION_MASK |
                             gtk.gdk.POINTER_MOTION_HINT_MASK )
        self.area.connect("expose-event", self.area_redraw)
        self.area.connect("motion-notify-event", self.motion_event)
        self.sw = gtk.ScrolledWindow()
        self.sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        window.add(self.sw)
        self.sw.add_with_viewport(self.area)

        self.sw.show()
        self.area.show()
        window.show()
        self.style = self.area.get_style()
        self.gc = self.style.fg_gc[gtk.STATE_NORMAL]

    def motion_event(self, area, event):
        '''
        Callback for mouse-moves over widget
        '''
        x,y = area.get_pointer()
        page = self.pixel2page(x,y)
        legend.set_data(page)

    def page2pixel(self,page):
        '''
        Place page into block of 1024 pages (usually 4MB)
        '''
        block_seq = int(page) / 1024
        x = block_seq % 32 * 32 + (page % 1024) % 32
        y = block_seq / 32 * 32 + (page % 1024) / 32
        return x, y

    def pixel2page(self, x, y):
        '''
        Computes pixels of page on pixel
        '''
        #Stolen code O_o
        block = ((y >> 5) << 5) + (x >> 5)
        return (block << 10) + ((y & 31) << 5) + (x & 31)

    def set_RGB4page(self, page, red, green=0, blue=0):
        x, y = self.page2pixel(page)
        pos = y * 1024 + x

        try:
            self.pixbuff[pos*3] = red
            self.pixbuff[pos*3 + 1] = green
            self.pixbuff[pos*3 + 2] = blue
        except:
            print "ERR:",pos*3

    def draw_pixbuff(self):
        '''
        Buffer is passed as string
        '''
        self.area.window.draw_rgb_image(self.gc, 0, 0, self.width, self.height,
                gtk.gdk.RGB_DITHER_NONE, self.pixbuff.tostring(), self.width*3)

    def area_redraw(self, area, event):
        '''
        expose-event handler
        '''
        self.draw_pixbuff()
        return True


if __name__ == "__main__":
    args = parser.parse_args()
    p = Painter(args)
    legend = Legend(150,300,args)
    canvas = MemoryCanvas(p.scr_w, p.scr_h)
    legend.draw_info()
    p.paint()
    gtk.main()
    

    
    

